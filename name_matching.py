import os
import re
import sys
from fuzzywuzzy import fuzz, process

def match_names(list_of_tracks, path_to_music_folder):
    # Change this to 'upated_list_of_tracks.txt' when running on whole thing

    # This keeps track of the number of songs that are on the spotify playlist
    with open(list_of_tracks, 'r') as f:
        data = f.read().split('\n')

    #### NEED TO MAKE SURE THERE ARE NO \/ IN THE NAMES OR IT WILL TRIP UP THE OS.RENAME() COMMAND

    for i in range(len(data)):
        if '/' in data[i]:
            data[i] = data[i].replace('/', "")


    #print('number of names:', len(data))


    # This keeps track of how many songs were downloaded
    counter = 0
    for filename in os.listdir(path_to_music_folder):
         if filename.endswith('.mp3'):
            counter += 1
    #print('number of files:', counter)

    # In an ideal world, counter == len(data)
    # If not, this means that some songs were misplaced/not downloaded.


    full_name = {}
    choices = []
    nums = [str(x) for x in range(counter)] # This is just to make sure every duplicate name is unique, will pop from this list everytime we have a duplicate

    # Create an array, 'choices' which, for every spotify song, contains the track name and artist.

    # Create dictionary 'full_name'
    # Key is the search string that was plugged into youtube for every spotify song
    # i.e. choices
    # Value is the full name of the song, as imported from spotify, which contains
    # all the information for id tags (track, artist, album and track no)

    for i in range(len(data)):
        choices.append(' '.join(data[i].split('_')[:2]))
        full_name[choices[i]] = data[i]


    # We're trying to match each downloaded song, which has the name of the corresponding youtube video, with the search string that we originally had plugged in to youtube (i.e. one of the element of full_name.keys())

    # fuzzy.process can allow us to do that. Once we've matched it, we can use 'choices' to get the full name that we'll want to input id tags


    # Change directory to where the music is
    os.chdir(path_to_music_folder)


    # fuzzy.process is used to match the proper name of songs from the tracklist,
    # with the name that was generated by ytmdl.

    # Problem is some songs from ytmdl/youtube have names that are non-descriptive
    # that will get matched with names from choices.

    for filename in os.listdir():
        if filename.endswith('.mp3'):

            new_name = process.extractOne(filename, choices, scorer = fuzz.token_sort_ratio)[0]

            if (full_name[new_name] + '.mp3') not in os.listdir():
                os.rename(filename, full_name[new_name] + '.mp3')
                continue
            else:
                os.rename(filename,'_duplicate_' + nums.pop(0) + '_' +  full_name[new_name]  + '.mp3')

    # Would be good to have a way of tracking down the songs that didn't make it
    # in the event that len(data) != counter
    # Here, we go through all the files in the directory, and remove that name from
    # the original list of songs that we downloaded from spotify ('choices').

    # Once we've gone through the whole directory, we print out whatever name from the spotify list of songs has not been assigned to any mp3 file (i.e. what's left in choices)

    # If, when iterating through the directory, an error is thrown when we try to delete the name from choices because it has already been deleted (i.e. that song name has been attributed more than once), then we print out that name immediately

    if len(data) != counter:

        for filename in os.listdir():
            if filename.endswith('.mp3'):
                try:
                    choices.remove(' '.join(filename.split('_')[:2]))
                except:
                    print(' '.join(filename.split('_')[:2]))

        print('WARNING: some songs were not properly matched with their correct name/not found. Check the duplicate names. Shown below are the names that have not been assigned.')
        for element in choices:
            print(full_name[element])


if __name__ == '__main__':
    if len(sys.argv) == 3:
        match_names(sys.argv[1], sys.argv[2])
    else:
        print('Try again with the following usage: %s list_of_tracks_from_spotify path_to_music_folder' %(sys.argv[0]))
